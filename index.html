<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ARIX Signature AR Christmas Tree</title>
    <style>
        /* --- UI 风格：深黑、科技感、极简 --- */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Roboto Mono', 'Courier New', monospace;
            color: #fff;
        }
        #loading {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center; font-size: 14px; letter-spacing: 2px;
            z-index: 999; color: #ffcf75;
            text-shadow: 0 0 10px rgba(255, 207, 117, 0.5);
        }
        canvas {
            display: block;
        }
        #video-feed { display: none; } /* 隐藏原始 Video 元素 */

        /* --- GUI 样式覆盖 (lil-gui) --- */
        .lil-gui.root { 
            position: absolute; top: 10px; left: 10px; z-index: 100;
            --background-color: rgba(5, 5, 5, 0.8);
            --text-color: #eee;
            --widget-color: #222;
            border: 1px solid #111;
        }

        /* --- 交互提示 HUD --- */
        #hud {
            position: absolute; bottom: 10px; right: 10px;
            pointer-events: none; font-size: 11px;
            line-height: 1.8; opacity: 0.9;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 12px;
            border-left: 2px solid #004b36;
        }
        .data-value { color: #ffcf75; font-weight: bold; }
        .alert { color: #ff3333; }
    </style>
</head>
<body>

    <div id="loading">INITIALIZING ARIX ENGINE...<br>[LOADING MEDIAPIPE AND SHADER]</div>
    <video id="video-feed" autoplay playsinline webkit-playsinline></video>
    
    <div id="hud">
        <div><span style="color:#aaa;">STATUS:</span> <span id="status-text" class="data-value">AWAITING CAMERA</span></div>
        <div><span style="color:#aaa;">MORPH STATE:</span> <span id="morph-state" class="data-value">SCATTERED</span></div>
        <div><span style="color:#aaa;">GESTURE:</span> <span id="gesture-state" class="data-value">NONE</span></div>
        <div style="margin-top:5px; border-top: 1px dotted #111;">
            <span style="color:#004b36; font-weight:bold;">CTRL:</span> FIST (Morph) | PINCH (Rotate)
        </div>
    </div>

    <script type="module">
        // --- 核心库 CDN 导入 ---
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
        import { EffectComposer } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js';
        import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.esm.min.js';
        
        // MediaPipe (必须加载整个 bundle)
        import { FilesetResolver, HandLandmarker } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/vision_bundle.js';

        // --- 全局配置与状态 ---
        const config = {
            PARTICLE_COUNT: 35000,
            TREE_HEIGHT: 12,
            TREE_RADIUS: 4.5,
            SCATTER_RADIUS: 25,
            ANIMATION_SPEED: 2.5,
            BLOOM_INTENSITY: 1.5,
            BLOOM_THRESHOLD: 0.2,
            EMERALD_COLOR: new THREE.Color('#004b36'),
            GOLD_COLOR: new THREE.Color('#ffcf75'),
        };

        const state = {
            morphTarget: 0.0, // 0.0 = Scattered, 1.0 = Tree
            currentProgress: 0.0,
            handDetected: false,
            gesture: 'NONE',
            pinchStartRotY: 0,
            isPinching: false,
            rotationYOffset: 0,
        };

        // --- Three.js 核心变量 ---
        let renderer, scene, camera, points;
        let composer, bloomPass;
        let video, handLandmarker;
        let shaderMaterial;

        // --- 核心着色器代码 (来自R3F项目) ---
        const VertexShader = `
            uniform float uProgress;
            uniform float uTime;
            
            attribute vec3 aScatterPosition;
            attribute float aSize;
            attribute float aRandom;
            
            varying vec3 vColor;
            varying float vRandom;

            // 缓动函数：让动画更有质感
            float cubicInOut(float t) {
              return t < 0.5 ? 4.0 * t * t * t : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;
            }

            void main() {
              vRandom = aRandom;
              
              // 1. 核心状态混合逻辑
              float easeProgress = cubicInOut(uProgress);
              
              // 当前位置 = 散落位置 -> 树位置 的插值 (position attribute holds treePosition)
              vec3 currentPos = mix(aScatterPosition, position, easeProgress);
              
              // 2. 添加奢华的微动 (漂浮感)
              float floatIntensity = mix(1.0, 0.1, easeProgress); 
              currentPos.x += sin(uTime * 0.5 + aRandom * 10.0) * 0.2 * floatIntensity;
              currentPos.y += cos(uTime * 0.3 + aRandom * 5.0) * 0.2 * floatIntensity;
              currentPos.z += sin(uTime * 0.7 + aRandom * 8.0) * 0.2 * floatIntensity;

              vec4 mvPosition = modelViewMatrix * vec4(currentPos, 1.0);
              gl_Position = projectionMatrix * mvPosition;

              // 3. 粒子大小随距离衰减
              gl_PointSize = aSize * (300.0 / -mvPosition.z);
            }
        `;

        const FragmentShader = `
            uniform vec3 uColorEmerald;
            uniform vec3 uColorGold;
            
            varying float vRandom;

            void main() {
                // 绘制圆形粒子
                vec2 xy = gl_PointCoord.xy - vec2(0.5);
                float ll = length(xy);
                if(ll > 0.5) discard;

                // 奢华配色逻辑
                vec3 finalColor = uColorEmerald;
                if (vRandom > 0.85) {
                  finalColor = uColorGold;
                  // 金色粒子更亮，以便触发 Bloom
                  finalColor *= 2.5; 
                } else {
                  finalColor *= 0.8;
                }

                // 边缘柔化
                float alpha = (0.5 - ll) * 2.0;
                
                gl_FragColor = vec4(finalColor, alpha);
            }
        `;


        // --- 1. 数据生成：双位置系统 (DP/TP) ---
        function generateDualPositions() {
            const pos = new Float32Array(config.PARTICLE_COUNT * 3); // Tree Shape (Target)
            const scat = new Float32Array(config.PARTICLE_COUNT * 3); // Scattered (Source)
            const sz = new Float32Array(config.PARTICLE_COUNT);
            const rnd = new Float32Array(config.PARTICLE_COUNT);

            for (let i = 0; i < config.PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                const rVal = Math.random();
                rnd[i] = rVal;

                // A. Tree Position (圆锥螺旋)
                const yNorm = Math.pow(Math.random(), 0.8); 
                const y = (1 - yNorm) * config.TREE_HEIGHT - (config.TREE_HEIGHT / 2);
                const radius = yNorm * config.TREE_RADIUS;
                const angle = Math.random() * Math.PI * 2 * 25;

                const thickness = Math.random() * 0.5;
                
                pos[i3] = Math.cos(angle) * (radius + thickness);
                pos[i3 + 1] = y;
                pos[i3 + 2] = Math.sin(angle) * (radius + thickness);

                // B. Scatter Position (球形星空)
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                const r = 5 + Math.random() * config.SCATTER_RADIUS;

                scat[i3] = r * Math.sin(phi) * Math.cos(theta);
                scat[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                scat[i3 + 2] = r * Math.cos(phi);

                // C. 大小：金色的更大
                sz[i] = rVal > 0.85 ? 5.0 + Math.random() * 3.0 : 2.5 + Math.random() * 2.0;
            }
            return { pos, scat, sz, rnd };
        }

        // --- 2. MediaPipe 初始化 ---
        async function setupMediaPipe() {
            document.getElementById('status-text').textContent = "LOADING MODEL...";
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO", numHands: 1
            });
            document.getElementById('status-text').textContent = "READY";
            document.getElementById('loading').style.display = 'none';
        }

        // --- 3. Three.js 场景设置 ---
        function setupScene() {
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            document.body.appendChild(renderer.domElement);

            // Scene and Camera
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020202);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 0, 25);
            camera.lookAt(0, 0, 0);

            // Data
            const { pos, scat, sz, rnd } = generateDualPositions();

            // Geometry and Shader Material
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3)); // Tree Position (Target)
            geometry.setAttribute('aScatterPosition', new THREE.BufferAttribute(scat, 3));
            geometry.setAttribute('aSize', new THREE.BufferAttribute(sz, 1));
            geometry.setAttribute('aRandom', new THREE.BufferAttribute(rnd, 1));
            
            shaderMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    uProgress: { value: state.currentProgress },
                    uTime: { value: 0 },
                    uColorEmerald: { value: config.EMERALD_COLOR },
                    uColorGold: { value: config.GOLD_COLOR },
                },
                vertexShader: VertexShader,
                fragmentShader: FragmentShader,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending,
            });

            points = new THREE.Points(geometry, shaderMaterial);
            scene.add(points);

            // Post-processing Setup (Bloom)
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            
            bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                config.BLOOM_INTENSITY, 
                config.BLOOM_THRESHOLD, 
                0.0 
            );
            composer.addPass(bloomPass);

            // Lighting (Essential for visibility, though particles are self-lit)
            scene.add(new THREE.AmbientLight(0xffffff, 0.1));
        }

        // --- 4. 手势处理逻辑 ---
        function detectGestures(landmarks) {
            const handStateEl = document.getElementById('gesture-state');
            handStateEl.textContent = 'NONE';
            handStateEl.classList.remove('alert');

            if (!landmarks || landmarks.length === 0) {
                state.handDetected = false;
                state.gesture = 'NONE';
                return null;
            }
            
            const lm = landmarks[0];

            // 坐标映射 (用于旋转控制)
            const mapCoord = (p) => new THREE.Vector3((p.x - 0.5) * 12, -(p.y - 0.5) * 8, -p.z * 5);
            const handPoints = lm.map(p => mapCoord(p));
            
            const thumbTip = handPoints[4]; 
            const indexTip = handPoints[8];
            const middleTip = handPoints[12];
            const wrist = handPoints[0];

            const pinchDist = thumbTip.distanceTo(indexTip);
            const thumbToMiddleDist = thumbTip.distanceTo(middleTip);

            // 握拳识别：中指指尖距离手腕非常近，且食指没有捏合
            const isFist = middleTip.distanceTo(wrist) < 2.0 && pinchDist > 1.0;
            const isPinching = pinchDist < 1.0 && thumbToMiddleDist > 2.0;

            let newGesture = 'HOVER';

            if (isFist) {
                newGesture = 'FIST';
                handStateEl.classList.add('alert');
            } else if (isPinching) {
                newGesture = 'PINCH';
                handStateEl.classList.add('data-value');
            }

            // 状态机和交互触发
            if (newGesture === 'FIST' && state.gesture !== 'FIST') {
                // 触发 Morph 状态切换
                state.morphTarget = state.morphTarget === 1.0 ? 0.0 : 1.0;
                const newMorphState = state.morphTarget === 1.0 ? 'TREE_SHAPE' : 'SCATTERED';
                document.getElementById('morph-state').textContent = newMorphState;
            }

            // PINCH 旋转控制
            if (newGesture === 'PINCH') {
                if (!state.isPinching) {
                    state.isPinching = true;
                    // 以手掌中心点 (9) 的 X 坐标作为旋转基准
                    state.pinchStartRotY = handPoints[9].x; 
                }
                 // 根据手部水平移动计算旋转量
                 const deltaX = handPoints[9].x - state.pinchStartRotY;
                 state.rotationYOffset = deltaX * 0.1;
            } else {
                state.isPinching = false;
            }
            
            state.gesture = newGesture; 
            handStateEl.textContent = newGesture;
            return handPoints[9]; // 返回手掌中心点用于其他可能的交互
        }


        // --- 5. 动画循环 ---
        let lastTime = 0;
        function animate(time) {
            requestAnimationFrame(animate);
            const delta = (time - lastTime) / 1000;
            lastTime = time;

            // MediaPipe 检测
            if (handLandmarker && video.readyState === 4) {
                handLandmarker.detectForVideo(video, performance.now());
                const results = handLandmarker.getRunningMode() === "VIDEO" ? handLandmarker.detectForVideo(video, performance.now()) : null;
                detectGestures(results ? results.landmarks : null);
            }
            
            // 核心动画：平滑插值 uProgress
            const diff = state.morphTarget - state.currentProgress;
            state.currentProgress += diff * delta * config.ANIMATION_SPEED;
            shaderMaterial.uniforms.uProgress.value = state.currentProgress;
            shaderMaterial.uniforms.uTime.value = time / 1000;

            // 应用旋转
            if (points) {
                if (state.isPinching) {
                    points.rotation.y += state.rotationYOffset;
                }
                // 自动旋转 (只在成型状态下轻微旋转)
                points.rotation.y += delta * 0.02 * state.currentProgress;
            }

            // 渲染
            composer.render();
        }

        // --- 6. 窗口调整 ---
        function onResize() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
            renderer.setSize(w, h);
            composer.setSize(w, h);
        }

        // --- 7. 主启动函数 ---
        async function init() {
            // 视频流设定
            video = document.getElementById('video-feed');
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'user', width: 1280, height: 720 } 
                });
                video.srcObject = stream;
                await new Promise(r => video.onloadedmetadata = r);
                video.play();
                
                // 1. 设置 MediaPipe
                await setupMediaPipe();

                // 2. 设置 Three.js 场景
                setupScene();
                
                // 3. 启动动画
                window.addEventListener('resize', onResize);
                animate(0);

            } catch (e) {
                document.getElementById('status-text').textContent = "CAMERA ERROR";
                console.error("Camera access failed:", e);
                document.getElementById('loading').innerHTML = "CAMERA ACCESS DENIED.<br>SYSTEM HALTED.";
            }
        }

        init();
    </script>
</body>
</html>
